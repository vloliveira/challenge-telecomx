# -*- coding: utf-8 -*-
"""TelecomX_BR.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11xb1RzMsijItvwbcRmw0LoV2ioiNKRKu

#üìå Extrac√£o
"""

import pandas as pd
import requests
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

"""### Leitura do Json"""

url = "https://raw.githubusercontent.com/ingridcristh/challenge2-data-science/refs/heads/main/TelecomX_Data.json"
df = pd.read_json(url)
df

"""### Normalizar oos dados aninhados"""

df_customer = pd.json_normalize(df['customer'])
df_phone = pd.json_normalize(df['phone'])
df_internet = pd.json_normalize(df['internet'])
df_account = pd.json_normalize(df['account'])
df_final = pd.concat([df[['customerID','Churn']],df_customer, df_phone, df_internet, df_account], axis=1)
df_final

"""#üîß Transforma√ß√£o

###Limpeza dos dados
"""

df_final['Contract'] = df_final['Contract'].str.replace('-', '', regex=True)
df_final['PaymentMethod'] = df_final['PaymentMethod'].str.replace('(automatic)', '', regex=True)
df_final['PaymentMethod'] = df_final['PaymentMethod'].str.replace('[()]', '', regex=True)
df_final['Charges.Total'] = df_final['Charges.Total'].apply(
    lambda x: float(str(x).replace(' ', '')) if str(x).strip() != '' else 0.0
)
df_final

# Remover valores nulos do Churn
# Identifica o valor que est√° causando o problema
valores_a_remover = df_final[~df_final['Churn'].isin(['Yes', 'No'])]['Churn'].unique()

# Filtra o DataFrame para manter apenas as linhas com 'Yes' ou 'No'
df_final = df_final[df_final['Churn'].isin(['Yes', 'No'])].copy()
print(df_final['Churn'].value_counts())

num_duplicados = df_final.duplicated().sum
print(f"\n Registros duplicados no dataset: {num_duplicados}")

print("\n Informa√ß√µes gerais:")
df_final.info()

print("\n Valores √∫nicos por coluna:")
for i in df_final.columns:
    print(f"{i}: {df_final[i].nunique()} valores √∫nicos")

print("\n Valores ausentes por coluna:")
df_final.isnull().sum()

"""#üìä Carga e an√°lise"""

print("An√°lise Descritiva \n")
df_final.describe()

df_final['Churn'].value_counts()

# Contagem de clientes que n√£o tiveram churn ('No') e n√£o usam OnlineSecurity ('No')
count = df_final[(df_final['Churn'] == 'No') & (df_final['OnlineSecurity'] == True)].shape[0]

print(f"N√∫mero de clientes com Churn 'No' e OnlineSecurity 'No': {count}")

sns.set_style("whitegrid")
plt.figure(figsize=(8, 6))
sns.countplot(data=df_final, x='Churn', palette='viridis')

plt.title('Distribui√ß√£o de evas√£o de clientes (Churn)', fontsize=16)
plt.xlabel('Churn', fontsize=12)
plt.ylabel('N√∫mero de Clientes', fontsize=12)

for p in plt.gca().patches:
    plt.gca().annotate(f'{int(p.get_height())}',
                       (p.get_x() + p.get_width() / 2., p.get_height()),
                       ha='center', va='center',
                       xytext=(0, 10),
                       textcoords='offset points')

plt.show()

sns.set_style("whitegrid")
plt.figure(figsize=(8, 6))
sns.countplot(data=df_final, x='gender', hue='Churn', palette='viridis')

plt.title('Distribui√ß√£o de evas√£o por G√™nero', fontsize=16)
plt.xlabel('G√™nero', fontsize=12)
plt.ylabel('N√∫mero de Clientes', fontsize=12)
plt.legend(title='Churn', loc='upper right')

ax = plt.gca()
for p in ax.patches:
    height = p.get_height()
    if height > 0:  # Verifica se a altura da barra √© maior que zero
        ax.annotate(f'{int(height)}',
                    (p.get_x() + p.get_width() / 2., height),
                    ha='center', va='center',
                    xytext=(0, 10),
                    textcoords='offset points')

plt.show()

plt.figure(figsize=(10, 6))
sns.countplot(data=df_final, x='Contract', hue='Churn', palette='viridis')

plt.title('Distribui√ß√£o de Churn por Tipo de Contrato', fontsize=16)
plt.xlabel('Tipo de Contrato', fontsize=12)
plt.ylabel('N√∫mero de Clientes', fontsize=12)
plt.legend(title='Churn', loc='upper right')

ax = plt.gca()
for p in ax.patches:
    height = p.get_height()
    if height > 0:
        ax.annotate(f'{int(height)}',
                    (p.get_x() + p.get_width() / 2., height),
                    ha='center', va='center',
                    xytext=(0, 10),
                    textcoords='offset points')

plt.show()

plt.figure(figsize=(12, 7))
sns.countplot(data=df_final, x='PaymentMethod', hue='Churn', palette='viridis')

plt.title('Distribui√ß√£o de Churn por M√©todo de Pagamento', fontsize=16)
plt.xlabel('M√©todo de Pagamento', fontsize=12)
plt.ylabel('N√∫mero de Clientes', fontsize=12)
plt.xticks(rotation=15, ha='right')
plt.legend(title='Churn', loc='upper right')

ax = plt.gca()
for p in ax.patches:
    height = p.get_height()
    if height > 0:
        ax.annotate(f'{int(height)}',
                    (p.get_x() + p.get_width() / 2., height),
                    ha='center', va='center',
                    xytext=(0, 10),
                    textcoords='offset points')

plt.show()

sns.set_style("whitegrid")
plt.figure(figsize=(8, 6))
ax = sns.countplot(data=df_final, x='SeniorCitizen', hue='Churn', palette='viridis')

for p in ax.patches:
    height = p.get_height()
    if height > 0:
        ax.annotate(f'{int(height)}',
                    (p.get_x() + p.get_width() / 2., height),
                    ha='center', va='center',
                    xytext=(0, 10),
                    textcoords='offset points')

plt.title('Distribui√ß√£o de Churn por Senioridade', fontsize=16)
plt.xlabel('Senior Citizen', fontsize=12)
plt.ylabel('N√∫mero de Clientes', fontsize=12)
plt.legend(title='Churn', loc='upper right')

plt.show()

sns.set_style("whitegrid")
fig, axes = plt.subplots(1, 3, figsize=(18, 6)) # 1 linha, 3 colunas

numeric_vars = ['tenure', 'Charges.Monthly', 'Charges.Total']
titles = ['M√©dia de Tempo de Contrato', 'M√©dia de Gastos Mensais', 'M√©dia de Total Gasto']
y_labels = ['Tempo de Contrato (Meses)', 'Gastos Mensais', 'Total Gasto']

for i, var in enumerate(numeric_vars):
    sns.barplot(ax=axes[i], data=df_final, x='Churn', y=var, palette='viridis')

    axes[i].set_title(titles[i], fontsize=14)
    axes[i].set_xlabel('Churn')
    axes[i].set_ylabel(y_labels[i])

    for p in axes[i].patches:
        height = p.get_height()
        axes[i].annotate(f'{height:.2f}',
                         (p.get_x() + p.get_width() / 2., height),
                         ha='center', va='bottom',
                         xytext=(0, 5),
                         textcoords='offset points')

plt.tight_layout()
plt.show()

"""#üìÑRelatorio Final

---

### üìÑ An√°lise de Evas√£o de Clientes (Churn)

Este relat√≥rio apresenta uma an√°lise sobre a evas√£o de clientes (Churn) da empresa TelecomX, focando em entender os principais motivos que levam os clientes a cancelar seus servi√ßos.

---

#### üîç **O que foi feito?**

Neste projeto, realizamos as seguintes etapas para analisar o problema de Churn:

1.  **Extra√ß√£o e Limpeza de Dados:** Importamos os dados de um arquivo JSON, organizamos as informa√ß√µes e realizamos uma limpeza rigorosa, tratando valores ausentes e corrigindo formatos de colunas. A etapa mais importante foi a remo√ß√£o de 224 registros com informa√ß√µes de Churn incompletas para garantir a precis√£o da nossa an√°lise.
2.  **An√°lise Explorat√≥ria:** Utilizando gr√°ficos de barra e de distribui√ß√£o, exploramos a rela√ß√£o entre a vari√°vel Churn e outras caracter√≠sticas dos clientes, como tipo de contrato, tempo de servi√ßo e forma de pagamento.

---

#### üìà **Principais Descobertas**

A an√°lise dos dados revelou padr√µes muito claros sobre a evas√£o de clientes. Os gr√°ficos mostraram que a decis√£o de sair da empresa n√£o √© aleat√≥ria e est√° diretamente ligada a fatores espec√≠ficos:

| Fator de Risco | Perfil do Cliente propenso a Churn |
| :--- | :--- |
| **Tempo de Contrato** | Clientes com **pouco tempo de servi√ßo** (m√©dia de **18 meses**) s√£o os que mais saem. |
| **Tipo de Plano** | Clientes com **contratos mensais** t√™m uma probabilidade muito maior de cancelar o servi√ßo. |
| **M√©todo de Pagamento** | O uso de **cheques eletr√¥nicos** est√° fortemente associado a uma maior taxa de evas√£o. |
| **Senioridade** | A taxa de Churn √© um pouco mais alta entre clientes idosos. |

---

#### üí° **Conclus√£o:** O Perfil do Cliente em Risco

Com base nos dados, podemos tra√ßar o perfil do cliente que tem maior probabilidade de churn: √© um cliente **novo**, que optou por um **plano mensal** e que realiza pagamentos via **cheque eletr√¥nico**. Este perfil sugere uma baixa lealdade e um compromisso fr√°gil com a empresa.

---

#### ‚úÖ **Recomenda√ß√µes Estrat√©gicas**

Para reter esses clientes de alto risco e reduzir a taxa de Churn, a TelecomX deve considerar as seguintes a√ß√µes:

1.  **Foco nos Clientes Novos:**
    * Implementar um programa de boas-vindas e acompanhamento nos primeiros meses.
    * Oferecer um atendimento proativo para garantir a satisfa√ß√£o inicial.
2.  **Incentivar Contratos de Longo Prazo:**
    * Criar ofertas especiais e descontos atraentes para que clientes em planos mensais migrem para contratos anuais.
3.  **Melhorar a Experi√™ncia de Pagamento:**
    * Investigar a causa da insatisfa√ß√£o dos clientes que usam cheques eletr√¥nicos.
    * Melhorar a usabilidade e a seguran√ßa desse m√©todo ou, alternativamente, incentivar a migra√ß√£o para outras formas de pagamento mais est√°veis.

Essas recomenda√ß√µes, baseadas em evid√™ncias dos dados, podem ajudar a TelecomX a construir relacionamentos mais duradouros e lucrativos com seus clientes.
"""

